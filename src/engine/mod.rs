pub mod error;
mod texture;
mod rect;

pub use self::texture::Texture;
pub use self::rect::Rect;
use self::error::Result;

use glium::texture::{RawImage2d, Texture2d, UncompressedFloatFormat, MipmapsOption};
use glium::{Blend, DisplayBuild, DrawParameters, IndexBuffer, Frame, VertexBuffer, Program, Surface};
use glium::backend::glutin_backend::{GlutinFacade, PollEventsIter};
use glium::glutin::WindowBuilder;
use glium::index::{self,PrimitiveType};
use std::io::Cursor;
use image;


pub struct Engine<'a> {
    pub display: GlutinFacade,
    pub program: Program,
    pub drawParameters: DrawParameters<'a>,
    pub width: u32,
    pub height: u32,
}

impl<'a> Engine<'a> {
    pub fn new(width: u32, height: u32) -> Result<Engine<'a>> {
        let display = WindowBuilder::new()
            .with_dimensions(width, height)
            .with_min_dimensions(width, height)
            .with_max_dimensions(width, height)
            .with_vsync()
            .build_glium()?;
        let program = Program::from_source(&display, include_str!("../../assets/shader.vert"), include_str!("../../assets/shader.frag"), None)?;

        Ok(Engine {
            display: display,
            program: program,
            width: width,
            height: height,
            drawParameters: DrawParameters {
                blend: Blend::alpha_blending(),
                .. DrawParameters::default()
            }
        })
    }

    pub fn begin_draw(&mut self) -> Frame {
        let mut frame = self.display.draw();
        frame.clear_color(0.0, 0.0, 1.0, 1.0);
        frame
    }

    pub fn events(&self) -> PollEventsIter {
        self.display.poll_events()
    }

    pub fn load_texture(&self, texture: &[u8]) -> Result<Texture> {
        let image = image::load(Cursor::new(texture), image::PNG)?.to_rgba();
        let image_dimensions = image.dimensions();
        let image = RawImage2d::from_raw_rgba_reversed(image.into_raw(), image_dimensions);
        return Ok(
            Texture2d::with_format(&self.display, image, UncompressedFloatFormat::F32F32F32F32, MipmapsOption::AutoGeneratedMipmaps)
                .map(|t| Texture::Texture2D(t))?
        );
    }

    pub fn draw_texture(&mut self, frame: &mut Frame, rect: Rect, texture: &Texture) -> Result<()> {
        let indices = IndexBuffer::<u8>::new(&self.display, PrimitiveType::TriangleStrip, &[0, 1, 2, 3])?;

        let left = ((rect.x as f32) / (self.width as f32) * 2f32) - 1f32;
        let top = 1f32 - ((rect.y as f32) / (self.height as f32) * 2f32);
        let right = (((rect.x + rect.width) as f32) / (self.width as f32) * 2f32) - 1f32;
        let bottom = 1f32 - (((rect.y + rect.height) as f32) / (self.height as f32) * 2f32);
        
        let vertex_buffer = VertexBuffer::new(&self.display,&[
            Vertex {
                position: [left, top],
                tex_coords: [0.0, 0.0],
            },
            Vertex {
                position: [right, top],
                tex_coords: [1.0, 0.0],
            },
            Vertex {
                position: [left, bottom],
                tex_coords: [0.0, 1.0],
            },
            Vertex {
                position: [right, bottom],
                tex_coords: [1.0, 1.0],
            }
        ])?;

        //let indices = index::NoIndices(PrimitiveType::TriangleStrip);
        let texture = match texture {
            &Texture::Texture2D(ref t) => t
        };
        
        let uniforms = uniform! {
            matrix: [
                [1.0, 0.0, 0.0, 0.0],
                [0.0, 1.0, 0.0, 0.0],
                [0.0, 0.0, 1.0, 0.0],
                [0.0, 0.0, 0.0, 1.0f32],
            ],
            tex: texture,
        };
        
        frame.draw(
            &vertex_buffer,
            &indices,
            &self.program,
            &uniforms,
            &self.drawParameters
        )?;
        Ok(())
    }
}

#[derive(Copy, Clone)]
struct Vertex {
    position: [f32; 2],
    tex_coords: [f32; 2],
}

implement_vertex!(Vertex, position, tex_coords);
